Данный проэкт решает задачу следующего содержания.

Дан текст (с любыми символами) и набор (точнее говоря, множество) слов (строк, содержащих только лишь буквы).
Необходимо найти всевозможные позиции слов в тексе, учитывая возможные опечатки в нём.

Будем различать два вида поиска:

- Абсолютный поиск
- Условный поиск

По умолчанию включён только абсолютный поиск.

Системные требования.

Операционная система с поддержкой языка Python 3.
Интерпретатор Python 3.

Способы и параметры запуска.

py indefinite_search [-h] [-a | -r] [-n] [-t [text] | -tf [path]]
                     [-w [words] | -wf [path]] [-i] [-b] [-s] [-e] [-m | -l n]
(ключи в пределах одной группы несовместимы)

Описание ключей:

  -h, --help                        вывод краткой справки на экран
  -a, --disable_absolute_search     замена абсолютного поиска на условный
  -r, --no_wrap                     при абсолютном поиске не разделять слова
                                    символом перевода строки
  -n, --enable_nominal_search       включение условного поиска
  -t [текст], --text [текст]        ввод текста
  -tf [путь], --text_file [путь]    указание ссылки на файл с текстом
  -w [слова], --words [слова]       слова через пробел
  -wf [путь], --words_file [путь]   указание ссылки на файл со словами
  -i, --ignore_case                 регистронезависимый поиск с помощью метода
                                    str.casefold()
  -b, --line_break                  удаление символов переноса строки
  -s, --sort                        отсортировать вывод для каждого слова по
                                    полученному расстоянию Левенштейна
  -e, --interactive                 если будет запрошен ввод с stdin, то он
                                    остановится после ввода пустой строчки
  -m, --match                       сравнивать слова на полное совпадение
                                    (формально, редакторское расстояние
                                    задаёт равным нулю)
  -l n, --length n                  изменяет редакторское расстояние
                                    (1 задано по умолчанию)



Про считывание информации.

В параметрах запуска учтено, что считывание текста или множества слов (независимо друг от друга)
происходит только из одного источника из всех перечисленных ниже:

1) Аргументы в терминале
2) Файл
3) STDIN

Если вы выбрали аргументы терминала, то текст вводится как единая строка, а слова - как список строк.
Пример: main.py -t 'This is my text' -w us temt this

Если вы выбрали в качестве источника файл, то текстом будет весь файл целиком, а словами - каждая непустая строчка файла.
Пример: main.py -tf 'C:\text file.txt' -w f thanksforyou

И, наконец, если вы не выбрали ни то, ни другое, то программа пригласит пользователя ввести данные в STDIN.
Для текста и набора слов правила одинаковы. Текст принимается, пока его вы его печатаете.
Напоминаем, что в оболочке bash закончить ввод можно сочетанием клавиш Ctrl + D, а в командной строке
Windows и в Windows PowerShell - Ctrl + Z.

Замечание 1. Нельзя вводить с STDIN и текст, и список слов.

Замечание 2. Чисто по техническим причинам крайне не рекомендуется вводить большой объем информации в
STDIN. Лучше записать эту информацию в файл и передать ссылку на него.

Про абсолютный поиск.

Разделим текст на слова (разделители - любой символ, отличный от буквы за возможным исключением переноса перед
символом новой строки). Для каждого слова из списка и слова из текста проведем сравнение. Если окажется, что
редакторское расстояние между ними не превышает заданного, то заносим результат в список ответов.

Этот способ поиска достаточно прост, но примитивен и не позволяет решить задачу на сто процетов.
Например, если одно слово было разделено на два путём вставки пробела, то в качестве ответа
не будет отобрана ни одна часть этого слова.

Про условный поиск.

Этот поиск является более тонким, но выявляет много лишних частей текста.

Для каждого слова в заданном множестве делаем следующие действия:

1) Ищем длину текущего слова. Обозначим её как k.
2) Если редакторское расстояние равно l, то строим следующую конечную последовательность:
{x(n)} = {0, 1, -1, 2, -2, ..., l, -l}.
Для каждого члена этой последовательности x(n) с номером n делаем следующие действия:
    1) Берем шаблон текста длины k + x(n) и рассчитываем редакторское расстояние
	    (перед этим выполнив некоторые другие действия, например приминение функции
		str.casefold() на обе строки) между текущим словом и шаблоном текста.
	2) Если найденное расстояние не превышает заданного, то позиция начала заносится в множество ответов.
	Примечание: для найденных расстояний, равных нулю и больших нуля, множества будут разными.
	3) Двигаем шаблон по тексту со сдвигом на один символ. Таким образом мы находим все искомые вхождения.
	Примечание: в завимости от ключа -b (--break) переносы слов будут удалены из строки из текста.
	Формально перенос слова - это знак минус (-), находящийся перед символом переноса строки.